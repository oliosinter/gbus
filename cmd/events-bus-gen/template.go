package main

var text = `// Code generated by events-bus-gen. DO NOT EDIT.
// source: {{$.File}}

// nolint
package {{.Package}}

{{- range $imp, $ali := .Imports}}

import {{ importPackage $imp $ali }}
{{- end}}

type (
{{- range $event := .Events}}
	// {{$.Name}}{{$event.Name}}HandlerFunc is a listener handler function for event '{{$event.Name}}'
	{{$.Name}}{{$event.Name}}HandlerFunc func({{$event | signature}})
{{- end}}
)

// New{{.Name}}Emitter creates new {{.Name}}Emitter
func New{{.Name}}Emitter() *{{.Name}}Emitter {
	return &{{.Name}}Emitter{}
}

// {{.Name}}Emitter implements events listener and events emitter operations
// for events {{.EventsList}}
type {{.Name}}Emitter struct {
{{- range $index, $event := .Events}}{{ if ne $index 0 }}
{{ end }}
	lock{{$event.Name}} sync.RWMutex

	on{{$event.Name}} []{{$.Name}}{{$event.Name}}HandlerFunc

	on{{$event.Name}}Async []{{$.Name}}{{$event.Name}}HandlerFunc
{{- end}}
}

// {{.Name}}Bus is a client side of event bus that allows subscribe to
// {{.EventsList}} events
type {{.Name}}Bus interface {
	{{.Name}}
	{{- range $event := .Events}}
	// On{{$event.Name}} adds event listener for '{{$event.Name}}' event
	On{{$event.Name}}(handler {{$.Name}}{{$event.Name}}HandlerFunc)
	// On{{$event.Name}}Async adds event listener for '{{$event.Name}}' event
	On{{$event.Name}}Async(handler {{$.Name}}{{$event.Name}}HandlerFunc)
	// Remove{{$event.Name}} excludes event listener
	Remove{{$event.Name}}(handler {{$.Name}}{{$event.Name}}HandlerFunc)
	{{- end}}
}{{range $event := .Events}}

// On{{$event.Name}} adds event listener for '{{$event.Name}}' event
func (bus *{{$.Name}}Emitter) On{{$event.Name}}(handler {{$.Name}}{{$event.Name}}HandlerFunc) {
	bus.lock{{$event.Name}}.Lock()
	defer bus.lock{{$event.Name}}.Unlock()
	bus.on{{$event.Name}} = append(bus.on{{$event.Name}}, handler)
}

// On{{$event.Name}}Async adds event listener for '{{$event.Name}}' event
func (bus *{{$.Name}}Emitter) On{{$event.Name}}Async(handler {{$.Name}}{{$event.Name}}HandlerFunc) {
	bus.lock{{$event.Name}}.Lock()
	defer bus.lock{{$event.Name}}.Unlock()
	bus.on{{$event.Name}}Async = append(bus.on{{$event.Name}}Async, handler)
}

// Remove{{$event.Name}} excludes event listener
func (bus *{{$.Name}}Emitter) Remove{{$event.Name}}(handler {{$.Name}}{{$event.Name}}HandlerFunc) {
	bus.lock{{$event.Name}}.Lock()
	defer bus.lock{{$event.Name}}.Unlock()
	var res []{{$.Name | title}}{{$event.Name}}HandlerFunc
	refVal := reflect.ValueOf(handler).Pointer()
	for _, f := range bus.on{{$event.Name}} {
		if reflect.ValueOf(f).Pointer() != refVal {
			res = append(res, f)
		}
	}
	bus.on{{$event.Name}} = res
	
	res = []{{$.Name | title}}{{$event.Name}}HandlerFunc{}
	for _, f := range bus.on{{$event.Name}}Async {
		if reflect.ValueOf(f).Pointer() != refVal {
			res = append(res, f)
		}
	}
	bus.on{{$event.Name}}Async = res
}

// {{$event.Name}} emits event with the same name
func (bus *{{$.Name}}Emitter) {{$event.Name}}({{$event | signature}}) {
	bus.lock{{$event.Name}}.RLock()
	defer bus.lock{{$event.Name}}.RUnlock()
	wg := &sync.WaitGroup{}
	for _, f := range bus.on{{$event.Name}}Async {
		wg.Add(1)
		go func(wg *sync.WaitGroup, f {{$.Name}}{{$event.Name}}HandlerFunc) {
			defer wg.Done()
			f({{$event | call}})
		}(wg, f)
	}
	for _, f := range bus.on{{$event.Name}} {
		f({{$event | call}})
	}
	wg.Wait()
}{{end}}
`
